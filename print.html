<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Askama</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="askama.html"><strong aria-hidden="true">1.</strong> Askama</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="creating_templates.html"><strong aria-hidden="true">3.</strong> Creating templates</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">4.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="configuration.html"><strong aria-hidden="true">5.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="template_syntax.html"><strong aria-hidden="true">6.</strong> Template syntax</a></li><li class="chapter-item expanded "><a href="filters.html"><strong aria-hidden="true">7.</strong> Filters</a></li><li class="chapter-item expanded "><a href="integrations.html"><strong aria-hidden="true">8.</strong> Integrations</a></li><li class="chapter-item expanded "><a href="performance.html"><strong aria-hidden="true">9.</strong> Performance</a></li><li class="chapter-item expanded "><a href="template_expansion.html"><strong aria-hidden="true">10.</strong> Template expansion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Askama</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="askama"><a class="header" href="#askama">Askama</a></h1>
<p><a href="https://docs.rs/askama/"><img src="https://docs.rs/askama/badge.svg" alt="Documentation" /></a>
<a href="https://crates.io/crates/askama"><img src="https://img.shields.io/crates/v/askama.svg" alt="Latest version" /></a>
<a href="https://github.com/djc/askama/actions?query=workflow%3ACI"><img src="https://github.com/djc/askama/workflows/CI/badge.svg" alt="Build Status" /></a>
<a href="https://discord.gg/ZucwjE6bmT"><img src="https://img.shields.io/discord/976380008299917365?logo=discord" alt="Chat" /></a></p>
<p>Askama implements a template rendering engine based on <a href="https://jinja.palletsprojects.com/">Jinja</a>.
It generates Rust code from your templates at compile time
based on a user-defined <code>struct</code> to hold the template's context.
See below for an example, or read <a href="https://djc.github.io/askama/">the book</a>.</p>
<p><strong>"Pretty exciting. I would love to use this already."</strong> --
<a href="http://lucumr.pocoo.org/">Armin Ronacher</a>, creator of Jinja</p>
<p>All feedback welcome. Feel free to file bugs, requests for documentation and
any other feedback to the <a href="https://github.com/djc/askama/issues">issue tracker</a> or <a href="https://twitter.com/djco/">tweet me</a>.</p>
<p>Askama was created by and is maintained by Dirkjan Ochtman. If you are in a
position to support ongoing maintenance and further development or use it
in a for-profit context, please consider supporting my open source work on
<a href="https://www.patreon.com/dochtman">Patreon</a>.</p>
<h3 id="feature-highlights"><a class="header" href="#feature-highlights">Feature highlights</a></h3>
<ul>
<li>Construct templates using a familiar, easy-to-use syntax</li>
<li>Benefit from the safety provided by Rust's type system</li>
<li>Template code is compiled into your crate for <a href="https://github.com/djc/template-benchmarks-rs">optimal performance</a></li>
<li>Optional built-in support for Actix, Axum, Gotham, Mendes, Rocket, tide, and warp web frameworks</li>
<li>Debugging features to assist you in template development</li>
<li>Templates must be valid UTF-8 and produce UTF-8 when rendered</li>
<li>IDE support available in <a href="https://plugins.jetbrains.com/plugin/16591-askama-template-support">JetBrains products</a></li>
<li>Works on stable Rust</li>
</ul>
<h3 id="supported-in-templates"><a class="header" href="#supported-in-templates">Supported in templates</a></h3>
<ul>
<li>Template inheritance</li>
<li>Loops, if/else statements and include support</li>
<li>Macro support</li>
<li>Variables (no mutability allowed)</li>
<li>Some built-in filters, and the ability to use your own</li>
<li>Whitespace suppressing with '-' markers</li>
<li>Opt-out HTML escaping</li>
<li>Syntax customization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>First, add the following to your crate's <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># in section [dependencies]
askama = "0.12.1"
</code></pre>
<p>Now create a directory called <code>templates</code> in your crate root.
In it, create a file called <code>hello.html</code>, containing the following:</p>
<pre><code>Hello, {{ name }}!
</code></pre>
<p>In any Rust file inside your crate, add the following:</p>
<pre><pre class="playground"><code class="language-rust">use askama::Template; // bring trait in scope

#[derive(Template)] // this will generate the code...
#[template(path = "hello.html")] // using the template in this path, relative
                                 // to the `templates` dir in the crate root
struct HelloTemplate&lt;'a&gt; { // the name of the struct can be anything
    name: &amp;'a str, // the field name should match the variable name
                   // in your template
}

fn main() {
    let hello = HelloTemplate { name: "world" }; // instantiate your struct
    println!("{}", hello.render().unwrap()); // then render it.
}</code></pre></pre>
<p>You should now be able to compile and run this code.</p>
<h2 id="using-integrations"><a class="header" href="#using-integrations">Using integrations</a></h2>
<p>To use one of the <a href="./integrations.html">integrations</a>, with axum as an example:</p>
<p>First, add this to your <code>Cargo.toml</code> instead:</p>
<pre><code class="language-toml"># in section [dependencies]
askama_axum = "0.4.0"
</code></pre>
<p>Then, import from askama_axum instead of askama:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use askama_axum::Template;
<span class="boring">}</span></code></pre></pre>
<p>This enables the implementation for axum's <code>IntoResponse</code> trait,
so an instance of the template can be returned as a response.</p>
<p>For other integrations, import and use their crate accordingly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-templates"><a class="header" href="#creating-templates">Creating Templates</a></h1>
<p>An Askama template is a <code>struct</code> definition which provides the template
context combined with a UTF-8 encoded text file (or inline source, see
below). Askama can be used to generate any kind of text-based format.
The template file's extension may be used to provide content type hints.</p>
<p>A template consists of <strong>text contents</strong>, which are passed through as-is,
<strong>expressions</strong>, which get replaced with content while being rendered, and
<strong>tags</strong>, which control the template's logic.
The <a href="template_syntax.html">template syntax</a> is very similar to <a href="http://jinja.pocoo.org/">Jinja</a>,
as well as Jinja-derivatives like <a href="http://twig.sensiolabs.org/">Twig</a> or
<a href="https://github.com/Keats/tera">Tera</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)] // this will generate the code...
#[template(path = "hello.html")] // using the template in this path, relative
                                 // to the `templates` dir in the crate root
struct HelloTemplate&lt;'a&gt; { // the name of the struct can be anything
    name: &amp;'a str, // the field name should match the variable name
                   // in your template
}
<span class="boring">}</span></code></pre></pre>
<h2 id="the-template-attribute"><a class="header" href="#the-template-attribute">The <code>template()</code> attribute</a></h2>
<p>Askama works by generating one or more trait implementations for any
<code>struct</code> type decorated with the <code>#[derive(Template)]</code> attribute. The
code generation process takes some options that can be specified through
the <code>template()</code> attribute. The following sub-attributes are currently
recognized:</p>
<ul>
<li>
<p><code>path</code> (as <code>path = "foo.html"</code>): sets the path to the template file. The
path is interpreted as relative to the configured template directories
(by default, this is a <code>templates</code> directory next to your <code>Cargo.toml</code>).
The file name extension is used to infer an escape mode (see below). In
web framework integrations, the path's extension may also be used to
infer the content type of the resulting response.
Cannot be used together with <code>source</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(path = "hello.html")]
struct HelloTemplate&lt;'a&gt; { ... }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>source</code> (as <code>source = "{{ foo }}"</code>): directly sets the template source.
This can be useful for test cases or short templates. The generated path
is undefined, which generally makes it impossible to refer to this
template from other templates. If <code>source</code> is specified, <code>ext</code> must also
be specified (see below). Cannot be used together with <code>path</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(source = "Hello {{ name }}")]
struct HelloTemplate&lt;'a&gt; {
    name: &amp;'a str,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>ext</code> (as <code>ext = "txt"</code>): lets you specify the content type as a file
extension. This is used to infer an escape mode (see below), and some
web framework integrations use it to determine the content type.
Cannot be used together with <code>path</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(source = "Hello {{ name }}", ext = "txt")]
struct HelloTemplate&lt;'a&gt; {
    name: &amp;'a str,
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>print</code> (as <code>print = "code"</code>): enable debugging by printing nothing
(<code>none</code>), the parsed syntax tree (<code>ast</code>), the generated code (<code>code</code>)
or <code>all</code> for both. The requested data will be printed to stdout at
compile time.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(path = "hello.html", print = "all")]
struct HelloTemplate&lt;'a&gt; { ... }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>block</code> (as <code>block = "block_name"</code>): renders the block by itself.
Expressions outside of the block are not required by the struct, and
inheritance is also supported. This can be useful when you need to
decompose your template for partial rendering, without needing to
extract the partial into a separate template or macro.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(path = "hello.html", block = "hello")]
struct HelloTemplate&lt;'a&gt; { ... }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>escape</code> (as <code>escape = "none"</code>): override the template's extension used for
the purpose of determining the escaper for this template. See the section
on configuring custom escapers for more information.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(path = "hello.html", escape = "none")]
struct HelloTemplate&lt;'a&gt; { ... }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>syntax</code> (as <code>syntax = "foo"</code>): set the syntax name for a parser defined
in the configuration file. The default syntax , "default", is the one
provided by Askama.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(path = "hello.html", syntax = "foo")]
struct HelloTemplate&lt;'a&gt; { ... }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>config</code> (as <code>config = "config_file_path"</code>): set the path for the config file
to be used. The path is interpreted as relative to your crate root.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(path = "hello.html", config = "config.toml")]
struct HelloTemplate&lt;'a&gt; { ... }
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-and-troubleshooting"><a class="header" href="#debugging-and-troubleshooting">Debugging and Troubleshooting</a></h1>
<p>You can view the parse tree for a template as well as the generated code by
changing the <code>template</code> attribute item list for the template struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(path = "hello.html", print = "all")]
struct HelloTemplate&lt;'a&gt; { ... }
<span class="boring">}</span></code></pre></pre>
<p>The <code>print</code> key can take one of four values:</p>
<ul>
<li><code>none</code> (the default value)</li>
<li><code>ast</code> (print the parse tree)</li>
<li><code>code</code> (print the generated code)</li>
<li><code>all</code> (print both parse tree and code)</li>
</ul>
<p>The resulting output will be printed to <code>stderr</code> during the compilation process.</p>
<p>The parse tree looks like this for the example template:</p>
<pre><code>[Lit("", "Hello,", " "), Expr(WS(false, false), Var("name")),
Lit("", "!", "\n")]
</code></pre>
<p>The generated code looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt; 'a &gt; ::askama::Template for HelloTemplate&lt; 'a &gt; {
    fn render_into(&amp;self, writer: &amp;mut ::std::fmt::Write) -&gt; ::askama::Result&lt;()&gt; {
        write!(
            writer,
            "Hello, {expr0}!",
            expr0 = &amp;::askama::MarkupDisplay::from(&amp;self.name),
        )?;
        Ok(())
    }
    fn extension() -&gt; Option&lt;&amp;'static str&gt; {
        Some("html")
    }
}
impl &lt; 'a &gt; ::std::fmt::Display for HelloTemplate&lt; 'a &gt; {
    fn fmt(&amp;self, f: &amp;mut ::std::fmt::Formatter) -&gt; ::std::fmt::Result {
        ::askama::Template::render_into(self, f).map_err(|_| ::std::fmt::Error {})
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>At compile time, Askama will read optional configuration values from
<code>askama.toml</code> in the crate root (the directory where <code>Cargo.toml</code> can
be found). Currently, this covers the directories to search for templates,
custom syntax configuration and escaper configuration.</p>
<p>This example file demonstrates the default configuration:</p>
<pre><code class="language-toml">[general]
# Directories to search for templates, relative to the crate root.
dirs = ["templates"]
# Unless you add a `-` in a block, whitespace characters won't be trimmed.
whitespace = "preserve"
</code></pre>
<h2 id="whitespace-control"><a class="header" href="#whitespace-control">Whitespace control</a></h2>
<p>In the default configuration, you can use the <code>-</code> operator to indicate that
whitespace should be suppressed before or after a block. For example:</p>
<pre><code class="language-jinja">&lt;div&gt;


{%- if something %}
Hello
{% endif %}
</code></pre>
<p>In the template above, only the whitespace between <code>&lt;div&gt;</code> and <code>{%-</code> will be
suppressed. If you set <code>whitespace</code> to <code>"suppress"</code>, whitespace characters before
and after each block will be suppressed by default. To preserve the whitespace
characters, you can use the <code>+</code> operator:</p>
<pre><code class="language-jinja">{% if something +%}
Hello
{%+ endif %}
</code></pre>
<p>In this example, <code>Hello</code> will be surrounded with newline characters.</p>
<p>There is a third possibility: in case you want to suppress all whitespace
characters except one, you can use <code>~</code>:</p>
<pre><code class="language-jinja">{% if something ~%}
Hello
{%~ endif %}
</code></pre>
<p>To be noted, if one of the trimmed characters is a newline, then the only
character remaining will be a newline.</p>
<p>If you want this to be the default behaviour, you can set <code>whitespace</code> to
<code>"minimize"</code>.</p>
<p>To be noted: you can also configure <code>whitespace</code> directly into the <code>template</code>
derive proc macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(whitespace = "suppress")]
pub struct SomeTemplate;
<span class="boring">}</span></code></pre></pre>
<p>If you configure <code>whitespace</code> directly into the <code>template</code> derive proc-macro,
it will take precedence over the one in your configuration file. So in this
case, if you already set <code>whitespace = "minimize"</code> into your configuration file,
it will be replaced by <code>suppress</code> for this template.</p>
<h2 id="custom-syntaxes"><a class="header" href="#custom-syntaxes">Custom syntaxes</a></h2>
<p>Here is an example that defines two custom syntaxes:</p>
<pre><code class="language-toml">[general]
default_syntax = "foo"

[[syntax]]
name = "foo"
block_start = "%{"
comment_start = "#{"
expr_end = "^^"

[[syntax]]
name = "bar"
block_start = "%%"
block_end = "%%"
comment_start = "%#"
expr_start = "%{"
</code></pre>
<p>A syntax block consists of at least the attribute <code>name</code> which uniquely
names this syntax in the project.</p>
<p>The following keys can currently be used to customize template syntax:</p>
<ul>
<li><code>block_start</code>, defaults to <code>{%</code></li>
<li><code>block_end</code>, defaults to <code>%}</code></li>
<li><code>comment_start</code>, defaults to <code>{#</code></li>
<li><code>comment_end</code>, defaults to <code>#}</code></li>
<li><code>expr_start</code>, defaults to <code>{{</code></li>
<li><code>expr_end</code>, defaults to <code>}}</code></li>
</ul>
<p>Values must be at least two characters long.
If a key is omitted, the value from the default syntax is used.</p>
<p>Here is an example of a custom escaper:</p>
<pre><code class="language-toml">[[escaper]]
path = "::tex_escape::Tex"
extensions = ["tex"]
</code></pre>
<p>An escaper block consists of the attributes <code>path</code> and <code>extensions</code>. <code>path</code>
contains a Rust identifier that must be in scope for templates using this
escaper. <code>extensions</code> defines a list of file extensions that will trigger
the use of that escaper. Extensions are matched in order, starting with the
first escaper configured and ending with the default escapers for HTML
(extensions <code>html</code>, <code>htm</code>, <code>xml</code>, <code>j2</code>, <code>jinja</code>, <code>jinja2</code>) and plain text
(no escaping; <code>md</code>, <code>yml</code>, <code>none</code>, <code>txt</code>, and the empty string). Note that
this means you can also define other escapers that match different extensions
to the same escaper.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-syntax"><a class="header" href="#template-syntax">Template Syntax</a></h1>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>Top-level template variables are defined by the template's context type.
You can use a dot (<code>.</code>) to access variable's attributes or methods.
Reading from variables is subject to the usual borrowing policies.
For example, <code>{{ name }}</code> will get the <code>name</code> field from the template
context,
while <code>{{ user.name }}</code> will get the <code>name</code> field of the <code>user</code>
field from the template context.</p>
<h2 id="using-constants-in-templates"><a class="header" href="#using-constants-in-templates">Using constants in templates</a></h2>
<p>You can use constants defined in your Rust code. For example if you
have:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const MAX_NB_USERS: usize = 2;
<span class="boring">}</span></code></pre></pre>
<p>defined in your crate root, you can then use it in your templates by
using <code>crate::MAX_NB_USERS</code>:</p>
<pre><code class="language-jinja">&lt;p&gt;The user limit is {{ crate::MAX_NB_USERS }}.&lt;/p&gt;
{% set value = 4 %}
{% if value &gt; crate::MAX_NB_USERS %}
    &lt;p&gt;{{ value }} is bigger than MAX_NB_USERS.&lt;/p&gt;
{% else %}
    &lt;p&gt;{{ value }} is less than MAX_NB_USERS.&lt;/p&gt;
{% endif %}
</code></pre>
<h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>Inside code blocks, you can also declare variables or assign values
to variables.
Assignments can't be imported by other templates.</p>
<p>Assignments use the <code>let</code> tag:</p>
<pre><code class="language-jinja">{% let name = user.name %}
{% let len = name.len() %}

{% let val -%}
{% if len == 0 -%}
  {% let val = "foo" -%}
{% else -%}
  {% let val = name -%}
{% endif -%}
{{ val }}
</code></pre>
<p>Like Rust, Askama also supports shadowing variables.</p>
<pre><code class="language-jinja">{% let foo = "bar" %}
{{ foo }}

{% let foo = "baz" %}
{{ foo }}
</code></pre>
<p>For compatibility with Jinja, <code>set</code> can be used in place of <code>let</code>.</p>
<h2 id="filters"><a class="header" href="#filters">Filters</a></h2>
<p>Values such as those obtained from variables can be post-processed
using <strong>filters</strong>.
Filters are applied to values using the pipe symbol (<code>|</code>) and may
have optional extra arguments in parentheses.
Filters can be chained, in which case the output from one filter
is passed to the next.</p>
<p>For example, <code>{{ "{:?}"|format(name|escape) }}</code> will escape HTML
characters from the value obtained by accessing the <code>name</code> field,
and print the resulting string as a Rust literal.</p>
<p>The built-in filters are documented as part of the
<a href="filters.html">filters documentation</a>.</p>
<p>To define your own filters, simply have a module named <code>filters</code> in
scope of the context deriving a <code>Template</code> <code>impl</code>. Note that in case of
name collision, the built in filters take precedence.</p>
<h2 id="filter-blocks"><a class="header" href="#filter-blocks">Filter blocks</a></h2>
<p>You can apply a <strong>filter</strong> on a whole block at once using <strong>filter
blocks</strong>:</p>
<pre><code class="language-text">{% filter lower %}
    {{ t }} / HELLO / {{ u }}
{% endfilter %}
</code></pre>
<p>The <code>lower</code> filter will be applied on the whole content.</p>
<p>Just like filters, you can combine them:</p>
<pre><code class="language-text">{% filter lower|capitalize %}
    {{ t }} / HELLO / {{ u }}
{% endfilter %}
</code></pre>
<p>In this case, <code>lower</code> will be called and then <code>capitalize</code> will be
called on what <code>lower</code> returned.</p>
<h2 id="whitespace-control-1"><a class="header" href="#whitespace-control-1">Whitespace control</a></h2>
<p>Askama considers all tabs, spaces, newlines and carriage returns to be
whitespace. By default, it preserves all whitespace in template code,
except that a single trailing newline character is suppressed.
However, whitespace before and after expression and block delimiters
can be suppressed by writing a minus sign directly following a
start delimiter or leading into an end delimiter.</p>
<p>Here is an example:</p>
<pre><code class="language-text">{% if foo %}
  {{- bar -}}
{% else if -%}
  nothing
{%- endif %}
</code></pre>
<p>This discards all whitespace inside the if/else block. If a literal
(any part of the template not surrounded by <code>{% %}</code> or <code>{{ }}</code>)
includes only whitespace, whitespace suppression on either side will
completely suppress that literal content.</p>
<p>If the whitespace default control is set to "suppress" and you want
to preserve whitespace characters on one side of a block or of an
expression, you need to use <code>+</code>. Example:</p>
<pre><code class="language-text">&lt;a href="/" {#+ #}
   class="something"&gt;text&lt;/a&gt;
</code></pre>
<p>In the above example, one whitespace character is kept
between the <code>href</code> and the <code>class</code> attributes.</p>
<p>There is a third possibility. In case you want to suppress all whitespace
characters except one (<code>"minimize"</code>), you can use <code>~</code>:</p>
<pre><code class="language-jinja">{% if something ~%}
Hello
{%~ endif %}
</code></pre>
<p>To be noted, if one of the trimmed characters is a newline, then the only
character remaining will be a newline.</p>
<p>Whitespace controls can also be defined by a
<a href="configuration.html">configuration file</a> or in the derive macro.
These definitions follow the global-to-local preference:</p>
<ol>
<li>Inline (<code>-</code>, <code>+</code>, <code>~</code>)</li>
<li>Derive (<code>#[template(whitespace = "suppress")]</code>)</li>
<li>Configuration (in <code>askama.toml</code>, <code>whitespace = "preserve"</code>)</li>
</ol>
<p>Two inline whitespace controls may point to the same whitespace span.
In this case, they are resolved by the following preference.</p>
<ol>
<li>Suppress (<code>-</code>)</li>
<li>Minimize (<code>~</code>)</li>
<li>Preserve (<code>+</code>)</li>
</ol>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>There are several ways that functions can be called within templates,
depending on where the function definition resides. These are:</p>
<ul>
<li>Template <code>struct</code> fields</li>
<li>Static functions</li>
<li>Struct/Trait implementations</li>
</ul>
<h3 id="template-struct-field"><a class="header" href="#template-struct-field">Template struct field</a></h3>
<p>When the function is a field of the template struct, we can simply call it
by invoking the name of the field, followed by parentheses containing any
required arguments. For example, we can invoke the function <code>foo</code> for the
following <code>MyTemplate</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(source = "{{ foo(123) }}", ext = "txt")]
struct MyTemplate {
  foo: fn(u32) -&gt; String,
}
<span class="boring">}</span></code></pre></pre>
<p>However, since we'll need to define this function every time we create an
instance of <code>MyTemplate</code>, it's probably not the most ideal way to associate
some behaviour for our template.</p>
<h3 id="static-functions"><a class="header" href="#static-functions">Static functions</a></h3>
<p>When a function exists within the same Rust module as the template
definition, we can invoke it using the <code>self</code> path prefix, where <code>self</code>
represents the scope of the module in which the template struct resides.</p>
<p>For example, here we call the function <code>foo</code> by writing <code>self::foo(123)</code>
within the <code>MyTemplate</code> struct source:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(val: u32) -&gt; String {
  format!("{}", val)
}

#[derive(Template)]
#[template(source = "{{ self::foo(123) }}", ext = "txt")]
struct MyTemplate;
<span class="boring">}</span></code></pre></pre>
<p>This has the advantage of being able to share functionality across multiple
templates, without needing to expose the function publicly outside of its
module.</p>
<p>However, we are not limited to local functions defined within the same module.
We can call <em>any</em> public function by specifying the full path to that function
within the template source. For example, given a utilities module such as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/templates/utils/mod.rs

pub fn foo(val: u32) -&gt; String {
  format!("{}", val)
}
<span class="boring">}</span></code></pre></pre>
<p>Within our <code>MyTemplate</code> source, we can call the <code>foo</code> function by writing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/templates/my_template.rs

#[derive(Template)]
#[template(source = "{{ crate::templates::utils::foo(123) }}", ext = "txt")]
struct MyTemplate;
<span class="boring">}</span></code></pre></pre>
<h3 id="struct--trait-implementations"><a class="header" href="#struct--trait-implementations">Struct / trait implementations</a></h3>
<p>Finally, we can invoke functions that are implementation methods of our
template struct, by referencing <code>Self</code> (note the uppercase <code>S</code>) as the path,
before calling our function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(source = "{{ Self::foo(self, 123) }}", ext = "txt")]
struct MyTemplate {
  count: u32,
};

impl MyTemplate {
  fn foo(&amp;self, val: u32) -&gt; String {
    format!("{} is the count, {} is the value", self.count, val)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>If the implemented method requires a reference to the struct itself,
such as is demonstrated in the above example, we can pass <code>self</code>
(note the lowercase <code>s</code>) as the first argument.</p>
<p>Similarly, using the <code>Self</code> path, we can also call any method belonging
to a trait that has been implemented for our template struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Hello {
  fn greet(name: &amp;str) -&gt; String;
}

#[derive(Template)]
#[template(source = r#"{{ Self::greet("world") }}"#, ext = "txt")]
struct MyTemplate;

impl Hello for MyTemplate {
  fn greet(name: &amp;str) -&gt; String {
    format!("Hello {}", name)
  }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="template-inheritance"><a class="header" href="#template-inheritance">Template inheritance</a></h2>
<p>Template inheritance allows you to build a base template with common
elements that can be shared by all inheriting templates.
A base template defines <strong>blocks</strong> that child templates can override.</p>
<h3 id="base-template"><a class="header" href="#base-template">Base template</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;{% block title %}{{ title }} - My Site{% endblock %}&lt;/title&gt;
    {% block head %}{% endblock %}
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="content"&gt;
      {% block content %}&lt;p&gt;Placeholder content&lt;/p&gt;{% endblock %}
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The <code>block</code> tags define three blocks that can be filled in by child
templates. The base template defines a default version of the block.
A base template must define one or more blocks in order to enable
inheritance. Blocks can only be specified at the top level of a template
or inside other blocks, not inside <code>if</code>/<code>else</code> branches or in <code>for</code>-loop
bodies.</p>
<p>It is also possible to use the name of the <code>block</code> in <code>endblock</code> (both in
declaration and use):</p>
<pre><code class="language-html">{% block content %}&lt;p&gt;Placeholder content&lt;/p&gt;{% endblock content %}
</code></pre>
<h3 id="child-template"><a class="header" href="#child-template">Child template</a></h3>
<p>Here's an example child template:</p>
<pre><code class="language-html">{% extends "base.html" %}

{% block title %}Index{% endblock %}

{% block head %}
  &lt;style&gt;
  &lt;/style&gt;
{% endblock %}

{% block content %}
  &lt;h1&gt;Index&lt;/h1&gt;
  &lt;p&gt;Hello, world!&lt;/p&gt;
  {% call super() %}
{% endblock %}
</code></pre>
<p>The <code>extends</code> tag tells the code generator that this template inherits
from another template. It will search for the base template relative to
itself before looking relative to the template base directory. It will
render the top-level content from the base template, and substitute
blocks from the base template with those from the child template. Inside
a block in a child template, the <code>super()</code> macro can be called to render
the parent block's contents.</p>
<p>Because top-level content from the child template is thus ignored, the <code>extends</code>
tag doesn't support whitespace control:</p>
<pre><code class="language-html">{%- extends "base.html" +%}
</code></pre>
<p>The above code is rejected because we used <code>-</code> and <code>+</code>. For more information
about whitespace control, take a look <a href="template_syntax.html#whitespace-control">here</a>.</p>
<h3 id="block-fragments"><a class="header" href="#block-fragments">Block fragments</a></h3>
<p>Additionally, a block can be rendered by itself. This can be useful when
you need to decompose your template for partial rendering, without
needing to extract the partial into a separate template or macro. This
can be done with the <code>block</code> parameter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(path = "...", block = "my_block")]
struct BlockFragment {
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="html-escaping"><a class="header" href="#html-escaping">HTML escaping</a></h2>
<p>Askama by default escapes variables if it thinks it is rendering HTML
content. It infers the escaping context from the extension of template
filenames, escaping by default if the extension is one of <code>html</code>, <code>htm</code>,
or <code>xml</code>. When specifying a template as <code>source</code> in an attribute, the
<code>ext</code> attribute parameter must be used to specify a type. Additionally,
you can specify an escape mode explicitly for your template by setting
the <code>escape</code> attribute parameter value (to <code>none</code> or <code>html</code>).</p>
<p>Askama escapes <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, <code>"</code>, and <code>'</code>, according to the
<a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#output-encoding-for-html-contexts">OWASP escaping recommendations</a>. Use the <code>safe</code> filter to
prevent escaping for a single expression, or the <code>escape</code> (or <code>e</code>)
filter to escape a single expression in an unescaped context.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Template)]
#[template(source = "{{strvar}}")]
struct TestTemplate {
    strvar: String,
}

fn main() {
    let s = TestTemplate {
        strvar: "// my &lt;html&gt; is \"unsafe\" &amp; should be 'escaped'".to_string(),
    };
    assert_eq!(
        s.render().unwrap(),
        "&amp;#x2f;&amp;#x2f; my &amp;lt;html&amp;gt; is &amp;quot;unsafe&amp;quot; &amp;amp; \
         should be &amp;#x27;escaped&amp;#x27;"
    );
}</code></pre></pre>
<h2 id="control-structures"><a class="header" href="#control-structures">Control structures</a></h2>
<h3 id="for"><a class="header" href="#for">For</a></h3>
<p>Loop over each item in an iterator. For example:</p>
<pre><code class="language-html">&lt;h1&gt;Users&lt;/h1&gt;
&lt;ul&gt;
{% for user in users %}
  &lt;li&gt;{{ user.name|e }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</code></pre>
<p>Inside for-loop blocks, some useful variables are accessible:</p>
<ul>
<li><em>loop.index</em>: current loop iteration (starting from 1)</li>
<li><em>loop.index0</em>: current loop iteration (starting from 0)</li>
<li><em>loop.first</em>: whether this is the first iteration of the loop</li>
<li><em>loop.last</em>: whether this is the last iteration of the loop</li>
</ul>
<pre><code class="language-html">&lt;h1&gt;Users&lt;/h1&gt;
&lt;ul&gt;
{% for user in users %}
   {% if loop.first %}
   &lt;li&gt;First: {{user.name}}&lt;/li&gt;
   {% else %}
   &lt;li&gt;User#{{loop.index}}: {{user.name}}&lt;/li&gt;
   {% endif %}
{% endfor %}
&lt;/ul&gt;
</code></pre>
<h3 id="if"><a class="header" href="#if">If</a></h3>
<p>The <code>if</code> statement essentially mirrors Rust's <a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code> expression</a>,
and is used as you might expect:</p>
<pre><code class="language-text">{% if users.len() == 0 %}
  No users
{% else if users.len() == 1 %}
  1 user
{% elif users.len() == 2 %}
  2 users
{% else %}
  {{ users.len() }} users
{% endif %}
</code></pre>
<h4 id="if-let"><a class="header" href="#if-let">If Let</a></h4>
<p>Additionally, <code>if let</code> statements are also supported and similarly
mirror Rust's <a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code> expressions</a>:</p>
<pre><code class="language-text">{% if let Some(user) = user %}
  {{ user.name }}
{% else %}
  No user
{% endif %}
</code></pre>
<h3 id="match"><a class="header" href="#match">Match</a></h3>
<p>In order to deal with Rust <code>enum</code>s in a type-safe way, templates support
match blocks from version 0.6. Here is a simple example showing how to
expand an <code>Option</code>:</p>
<pre><code class="language-text">{% match item %}
  {% when Some with ("foo") %}
    Found literal foo
  {% when Some with (val) %}
    Found {{ val }}
  {% when None %}
{% endmatch %}
</code></pre>
<p>That is, a <code>match</code> block can optionally contain some whitespace (but
no other literal content), followed by a number of <code>when</code> blocks
and an optional <code>else</code> block. Each <code>when</code> block must name a list of
matches (<code>(val)</code>), optionally introduced with a variant name. The
<code>else</code> block is equivalent to matching on <code>_</code> (matching anything).</p>
<p>Struct-like enum variants are supported from version 0.8, with the list
of matches surrounded by curly braces instead (<code>{ field }</code>).  New names
for the fields can be specified after a colon in the list of matches
(<code>{ field: val }</code>).</p>
<h3 id="include"><a class="header" href="#include">Include</a></h3>
<p>The <em>include</em> statement lets you split large or repetitive blocks into
separate template files. Included templates get full access to the context
in which they're used, including local variables like those from loops:</p>
<pre><code class="language-text">{% for i in iter %}
  {% include "item.html" %}
{% endfor %}
</code></pre>
<pre><code class="language-text">* Item: {{ i }}
</code></pre>
<p>The path to include must be a string literal, so that it is known at
compile time. Askama will try to find the specified template relative
to the including template's path before falling back to the absolute
template path. Use <code>include</code> within the branches of an <code>if</code>/<code>else</code>
block to use includes more dynamically.</p>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<p>Askama supports string literals (<code>"foo"</code>) and integer literals (<code>1</code>).
It supports almost all binary operators that Rust supports,
including arithmetic, comparison and logic operators.
The parser applies the same precedence order as the Rust compiler.
Expressions can be grouped using parentheses.
The HTML special characters <code>&amp;</code>, <code>&lt;</code> and <code>&gt;</code> will be replaced with their
character entities unless the <code>escape</code> mode is disabled for a template.
Methods can be called on variables that are in scope, including <code>self</code>.</p>
<pre><code>{{ 3 * 4 / 2 }}
{{ 26 / 2 % 7 }}
{{ 3 % 2 * 6 }}
{{ 1 * 2 + 4 }}
{{ 11 - 15 / 3 }}
{{ 4 + 5 % 3 }}
{{ 4 | 2 + 5 &amp; 2 }}
</code></pre>
<p><strong>Warning</strong>: if the result of an expression (a <code>{{ }}</code> block) is
equivalent to <code>self</code>, this can result in a stack overflow from infinite
recursion. This is because the <code>Display</code> implementation for that expression
will in turn evaluate the expression and yield <code>self</code> again.</p>
<h2 id="templates-in-templates"><a class="header" href="#templates-in-templates">Templates in templates</a></h2>
<p>Using expressions, it is possible to delegate rendering part of a template to another template.
This makes it possible to inject modular template sections into other templates and facilitates
testing and reuse.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use askama::Template;
#[derive(Template)]
#[template(source = "Section 1: {{ s1 }}", ext = "txt")]
struct RenderInPlace&lt;'a&gt; {
   s1: SectionOne&lt;'a&gt;
}

#[derive(Template)]
#[template(source = "A={{ a }}\nB={{ b }}", ext = "txt")]
struct SectionOne&lt;'a&gt; {
   a: &amp;'a str,
   b: &amp;'a str,
}

let t = RenderInPlace { s1: SectionOne { a: "a", b: "b" } };
assert_eq!(t.render().unwrap(), "Section 1: A=a\nB=b")
<span class="boring">}</span></code></pre></pre>
<p>See the example
<a href="https://github.com/djc/askama/blob/main/testing/tests/render_in_place.rs">render in place</a>
using a vector of templates in a for block.</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Askama supports block comments delimited by <code>{#</code> and <code>#}</code>.</p>
<pre><code class="language-jinja">{# A Comment #}
</code></pre>
<p>Like Rust, Askama also supports nested block comments.</p>
<pre><code class="language-jinja">{#
A Comment
{# A nested comment #}
#}
</code></pre>
<h2 id="recursive-structures"><a class="header" href="#recursive-structures">Recursive Structures</a></h2>
<p>Recursive implementations should preferably use a custom iterator and
use a plain loop. If that is not doable, call <code>.render()</code>
directly by using an expression as shown below.
Including self does not work, see #105 and #220 .</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use askama::Template;

#[derive(Template)]
#[template(source = r#"
//! {% for item in children %}
   {{ item }}
{% endfor %}
"#, ext = "html", escape = "none")]
struct Item&lt;'a&gt; {
    name: &amp;'a str,
    children: &amp;'a [Item&lt;'a&gt;],
}
<span class="boring">}</span></code></pre></pre>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>You can define macros within your template by using <code>{% macro name(args) %}</code>, ending with <code>{% endmacro %}</code>.</p>
<p>You can then call it with <code>{% call name(args) %}</code>:</p>
<pre><code class="language-jinja">{% macro heading(arg) %}

&lt;h1&gt;{{arg}}&lt;/h1&gt;

{% endmacro %}

{% call heading(s) %}
</code></pre>
<p>You can place macros in a separate file and use them in your templates by using <code>{% import %}</code>:</p>
<pre><code class="language-jinja">{%- import "macro.html" as scope -%}

{% call scope::heading(s) %}
</code></pre>
<p>You can optionally specify the name of the macro in <code>endmacro</code>:</p>
<pre><code class="language-jinja">{% macro heading(arg) %}&lt;p&gt;{{arg}}&lt;/p&gt;{% endmacro heading %}
</code></pre>
<p>You can also specify arguments by their name (as defined in the macro):</p>
<pre><code class="language-jinja">{% macro heading(arg, bold) %}

&lt;h1&gt;{{arg}} &lt;b&gt;{{bold}}&lt;/b&gt;&lt;/h1&gt;

{% endmacro %}

{% call heading(bold="something", arg="title") %}
</code></pre>
<p>You can use whitespace characters around <code>=</code>:</p>
<pre><code class="language-jinja">{% call heading(bold = "something", arg = "title") %}
</code></pre>
<p>You can mix named and non-named arguments when calling a macro:</p>
<pre><code>{% call heading("title", bold="something") %}
</code></pre>
<p>However please note than named arguments must always come <strong>last</strong>.</p>
<p>Another thing to note, if a named argument is referring to an argument that would
be used for a non-named argument, it will error:</p>
<pre><code class="language-jinja">{% macro heading(arg1, arg2, arg3, arg4) %}
{% endmacro %}

{% call heading("something", "b", arg4="ah", arg2="title") %}
</code></pre>
<p>In here it's invalid because <code>arg2</code> is the second argument and would be used by
<code>"b"</code>. So either you replace <code>"b"</code> with <code>arg3="b"</code> or you pass <code>"title"</code> before:</p>
<pre><code class="language-jinja">{% call heading("something", arg3="b", arg4="ah", arg2="title") %}
{# Equivalent of: #}
{% call heading("something", "title", "b", arg4="ah") %}
</code></pre>
<h2 id="calling-rust-macros"><a class="header" href="#calling-rust-macros">Calling Rust macros</a></h2>
<p>It is possible to call rust macros directly in your templates:</p>
<pre><code class="language-jinja">{% let s = format!("{}", 12) %}
</code></pre>
<p>One important thing to note is that contrary to the rest of the expressions,
Askama cannot know if a token given to a macro is a variable or something
else, so it will always default to generate it "as is". So if you have:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! test_macro{
    ($entity:expr) =&gt; {
        println!("{:?}", &amp;$entity);
    }
}

#[derive(Template)]
#[template(source = "{{ test_macro!(entity) }}", ext = "txt")]
struct TestTemplate&lt;'a&gt; {
    entity: &amp;'a str,
}
<span class="boring">}</span></code></pre></pre>
<p>It will not compile, telling you it doesn't know <code>entity</code>. It didn't infer
that <code>entity</code> was a field of the current type unlike usual. You can go
around this limitation by binding your field's value into a variable:</p>
<pre><code class="language-jinja">{% let entity = entity; %}
{{ test_macro!(entity) }}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filters-1"><a class="header" href="#filters-1">Filters</a></h1>
<p>Values such as those obtained from variables can be post-processed
using <strong>filters</strong>.
Filters are applied to values using the pipe symbol (<code>|</code>) and may
have optional extra arguments in parentheses.
Note that the pipe symbol must not be surrounded by spaces;
otherwise, it will be interpreted as the <code>BitOr</code> operator.
Filters can be chained, in which case the output from one filter
is passed to the next.</p>
<pre><code>{{ "HELLO"|lower }}
</code></pre>
<p>Askama has a collection of built-in filters, documented below, but can also include custom filters.
Additionally, the <code>json</code> filter is included in the built-in filters, but is disabled by default.
Enable it with Cargo features (see below for more information).</p>
<p><strong>Table of contents</strong></p>
<ul>
<li>
<p><strong><a href="filters.html#built-in-filters">Built-in filters</a>:</strong></p>
<ul>
<li><a href="filters.html#abs"><code>abs</code></a></li>
<li><a href="filters.html#as_ref"><code>as_ref</code></a></li>
<li><a href="filters.html#capitalize"><code>capitalize</code></a></li>
<li><a href="filters.html#center"><code>center</code></a></li>
<li><a href="filters.html#deref"><code>deref</code></a></li>
<li><a href="filters.html#escape--e"><code>escape|e</code></a></li>
<li><a href="filters.html#filesizeformat"><code>filesizeformat</code></a></li>
<li><a href="filters.html#fmt"><code>fmt</code></a></li>
<li><a href="filters.html#format"><code>format</code></a></li>
<li><a href="filters.html#indent"><code>indent</code></a></li>
<li><a href="filters.html#join"><code>join</code></a></li>
<li><a href="filters.html#linebreaks"><code>linebreaks</code></a></li>
<li><a href="filters.html#linebreaksbr"><code>linebreaksbr</code></a></li>
<li><a href="filters.html#lower--lowercase"><code>lower|lowercase</code></a></li>
<li><a href="filters.html#safe"><code>safe</code></a></li>
<li><a href="filters.html#title"><code>title</code></a></li>
<li><a href="filters.html#trim"><code>trim</code></a></li>
<li><a href="filters.html#truncate"><code>truncate</code></a></li>
<li><a href="filters.html#upper--uppercase"><code>upper|uppercase</code></a></li>
<li><a href="filters.html#urlencode"><code>urlencode</code></a></li>
<li><a href="filters.html#wordcount"><code>wordcount</code></a></li>
</ul>
</li>
<li>
<p><strong><a href="filters.html#optional--feature-gated-filters">Optional / feature gated filters</a>:</strong><br />
<a href="filters.html#json--tojson"><code>json|tojson</code></a>,</p>
</li>
<li>
<p><strong><a href="filters.html#custom-filters">Custom filters</a></strong></p>
</li>
</ul>
<h2 id="built-in-filters"><a class="header" href="#built-in-filters">Built-In Filters</a></h2>
<h3 id="abs"><a class="header" href="#abs">abs</a></h3>
<p>Returns the absolute value.</p>
<pre><code>{{ -2|abs }}
</code></pre>
<p>Output:</p>
<pre><code>2
</code></pre>
<h3 id="as_ref"><a class="header" href="#as_ref">as_ref</a></h3>
<p>Creates a reference to the given argument.</p>
<pre><code>{{ "a"|as_ref }}
{{ self.x|as_ref }}
</code></pre>
<p>will become:</p>
<pre><code>&amp;"a"
&amp;self.x
</code></pre>
<h3 id="capitalize"><a class="header" href="#capitalize">capitalize</a></h3>
<p>Capitalize a value. The first character will be uppercase, all others lowercase:</p>
<pre><code>{{ "hello"|capitalize }}
</code></pre>
<p>Output:</p>
<pre><code>Hello
</code></pre>
<h3 id="center"><a class="header" href="#center">center</a></h3>
<p>Centers the value in a field of a given width:</p>
<pre><code>-{{ "a"|center(5) }}-
</code></pre>
<p>Output:</p>
<pre><code>-  a  -
</code></pre>
<h3 id="deref"><a class="header" href="#deref">deref</a></h3>
<p>Dereferences the given argument.</p>
<pre><code>{% let s = String::from("a")|as_ref %}
{% if s|deref == String::from("b") %}
{% endif %}
</code></pre>
<p>will become:</p>
<pre><code>let s = &amp;String::from("a");
if *s == String::from("b") {}
</code></pre>
<h3 id="escape--e"><a class="header" href="#escape--e">escape | e</a></h3>
<p>Escapes HTML characters in strings:</p>
<pre><code>{{ "Escape &lt;&gt;&amp;"|e }}
</code></pre>
<p>Output:</p>
<pre><code>Escape &amp;lt;&amp;gt;&amp;amp;
</code></pre>
<p>Optionally, it is possible to specify and override which escaper is used.
Consider a template where the escaper is configured as <a href="creating_templates.html#the-template-attribute"><code>escape = "none"</code></a>.
However, somewhere escaping using the HTML escaper is desired.
Then it is possible to override and use the HTML escaper like this:</p>
<pre><code class="language-jinja">{{ "Don't Escape &lt;&gt;&amp;"|escape }}
{{ "Don't Escape &lt;&gt;&amp;"|e }}

{{ "Escape &lt;&gt;&amp;"|escape("html") }}
{{ "Escape &lt;&gt;&amp;"|e("html") }}
</code></pre>
<p>Output:</p>
<pre><code class="language-text">Don't Escape &lt;&gt;&amp;
Don't Escape &lt;&gt;&amp;

Escape &amp;lt;&amp;gt;&amp;amp;
Escape &amp;lt;&amp;gt;&amp;amp;
</code></pre>
<h3 id="filesizeformat"><a class="header" href="#filesizeformat">filesizeformat</a></h3>
<p>Returns adequate string representation (in KB, ..) of number of bytes:</p>
<pre><code>{{ 1000|filesizeformat }}
</code></pre>
<p>Output:</p>
<pre><code>1 KB
</code></pre>
<h3 id="fmt"><a class="header" href="#fmt">fmt</a></h3>
<p>Formats arguments according to the specified format</p>
<p>The <em>second</em> argument to this filter must be a string literal (as in normal
Rust). The two arguments are passed through to <a href="https://doc.rust-lang.org/stable/std/macro.format.html"><code>format!()</code></a> by
the Askama code generator, but the order is swapped to support filter
composition.</p>
<pre><code class="language-text">{{ value|fmt("{:?}") }}
</code></pre>
<p>As an example, this allows filters to be composed like the following.
Which is not possible using the <code>format</code> filter.</p>
<pre><code class="language-text">{{ value|capitalize|fmt("{:?}") }}
</code></pre>
<h3 id="format"><a class="header" href="#format">format</a></h3>
<p>Formats arguments according to the specified format.</p>
<p>The first argument to this filter must be a string literal (as in normal Rust).</p>
<p>All arguments are passed through to <a href="https://doc.rust-lang.org/stable/std/macro.format.html"><code>format!()</code></a> by the Askama code generator.</p>
<pre><code>{{ "{:?}"|format(var) }}
</code></pre>
<h3 id="indent"><a class="header" href="#indent">indent</a></h3>
<p>Indent newlines with width spaces.</p>
<pre><code>{{ "hello\nfoo\nbar"|indent(4) }}
</code></pre>
<p>Output:</p>
<pre><code>hello
    foo
    bar
</code></pre>
<h3 id="join"><a class="header" href="#join">join</a></h3>
<p>Joins iterable into a string separated by provided argument.</p>
<pre><code>array = &amp;["foo", "bar", "bazz"]
</code></pre>
<pre><code>{{ array|join(", ") }}
</code></pre>
<p>Output:</p>
<pre><code>foo, bar, bazz
</code></pre>
<h3 id="linebreaks"><a class="header" href="#linebreaks">linebreaks</a></h3>
<p>Replaces line breaks in plain text with appropriate HTML.</p>
<p>A single newline becomes an HTML line break <code>&lt;br&gt;</code> and a new line followed by a blank line becomes a paragraph break <code>&lt;p&gt;</code>.</p>
<pre><code>{{ "hello\nworld\n\nfrom\naskama"|linebreaks }}
</code></pre>
<p>Output:</p>
<pre><code>&lt;p&gt;hello&lt;br /&gt;world&lt;/p&gt;&lt;p&gt;from&lt;br /&gt;askama&lt;/p&gt;
</code></pre>
<h3 id="linebreaksbr"><a class="header" href="#linebreaksbr">linebreaksbr</a></h3>
<p>Converts all newlines in a piece of plain text to HTML line breaks.</p>
<pre><code>{{ "hello\nworld\n\nfrom\naskama"|linebreaks }}
</code></pre>
<p>Output:</p>
<pre><code>hello&lt;br /&gt;world&lt;br /&gt;&lt;br /&gt;from&lt;br /&gt;askama
</code></pre>
<h3 id="paragraphbreaks"><a class="header" href="#paragraphbreaks">paragraphbreaks</a></h3>
<p>A new line followed by a blank line becomes <code>&lt;p&gt;</code>, but, unlike <code>linebreaks</code>, single new lines are ignored and no <code>&lt;br/&gt;</code> tags are generated.</p>
<p>Consecutive double line breaks will be reduced down to a single paragraph break.</p>
<p>This is useful in contexts where changing single line breaks to line break tags would interfere with other HTML elements, such as lists and nested <code>&lt;div&gt;</code> tags.</p>
<pre><code>{{ "hello\nworld\n\nfrom\n\n\n\naskama"|paragraphbreaks }}
</code></pre>
<p>Output:</p>
<pre><code>&lt;p&gt;hello\nworld&lt;/p&gt;&lt;p&gt;from&lt;/p&gt;&lt;p&gt;askama&lt;/p&gt;
</code></pre>
<h3 id="lower--lowercase"><a class="header" href="#lower--lowercase">lower | lowercase</a></h3>
<p>Converts to lowercase.</p>
<pre><code>{{ "HELLO"|lower }}
</code></pre>
<p>Output:</p>
<pre><code>hello
</code></pre>
<h3 id="safe"><a class="header" href="#safe">safe</a></h3>
<p>Marks a string (or other Display type) as safe. By default all strings are escaped according to the format.</p>
<pre><code>{{ "&lt;p&gt;I'm Safe&lt;/p&gt;"|safe }}
</code></pre>
<p>Output:</p>
<pre><code>&lt;p&gt;I'm Safe&lt;/p&gt;
</code></pre>
<h3 id="title"><a class="header" href="#title">title</a></h3>
<p>Return a title cased version of the value. Words will start with uppercase letters, all
remaining characters are lowercase.</p>
<pre><code>{{ "hello WORLD"|title }}
</code></pre>
<p>Output:</p>
<pre><code>Hello World
</code></pre>
<h3 id="trim"><a class="header" href="#trim">trim</a></h3>
<p>Strip leading and trailing whitespace.</p>
<pre><code>{{ " hello "|trim }}
</code></pre>
<p>Output:</p>
<pre><code>hello
</code></pre>
<h3 id="truncate"><a class="header" href="#truncate">truncate</a></h3>
<p>Limit string length, appends '...' if truncated.</p>
<pre><code>{{ "hello"|truncate(2) }}
</code></pre>
<p>Output:</p>
<pre><code>he...
</code></pre>
<h3 id="upper--uppercase"><a class="header" href="#upper--uppercase">upper | uppercase</a></h3>
<p>Converts to uppercase.</p>
<pre><code>{{ "hello"|upper }}
</code></pre>
<p>Output:</p>
<pre><code>HELLO
</code></pre>
<h3 id="urlencode"><a class="header" href="#urlencode">urlencode</a></h3>
<p>Percent encodes the string. Replaces reserved characters with the % escape character followed by a byte value as two hexadecimal digits.</p>
<pre><code>hello?world
</code></pre>
<p>Output:</p>
<pre><code>hello%3Fworld
</code></pre>
<h3 id="wordcount"><a class="header" href="#wordcount">wordcount</a></h3>
<p>Count the words in that string.</p>
<pre><code>{{ "askama is sort of cool"|wordcount }}
</code></pre>
<p>Output:</p>
<pre><code>5
</code></pre>
<h2 id="optional--feature-gated-filters"><a class="header" href="#optional--feature-gated-filters">Optional / feature gated filters</a></h2>
<p>The following filters can be enabled by requesting the respective feature in the Cargo.toml
<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">dependencies section</a>, e.g.</p>
<pre><code>[dependencies]
askama = { version = "0.11.2", features = "serde-json" }
</code></pre>
<h3 id="json--tojson"><a class="header" href="#json--tojson"><code>json</code> | <code>tojson</code></a></h3>
<p>Enabling the <code>serde-json</code> feature will enable the use of the <code>json</code> filter.
This will output formatted JSON for any value that implements the required
<a href="https://docs.rs/serde/1.*/serde/trait.Serialize.html"><code>Serialize</code></a> trait.
The generated string does not contain ampersands <code>&amp;</code>, chevrons <code>&lt; &gt;</code>, or apostrophes <code>'</code>.</p>
<p>To use it in a <code>&lt;script&gt;</code> you can combine it with the safe filter.
In HTML attributes, you can either use it in quotation marks <code>"{{data|json}}"</code> as is,
or in apostrophes with the (optional) safe filter <code>'{{data|json|safe}}'</code>.
In HTML texts the output of e.g. <code>&lt;pre&gt;{{data|json|safe}}&lt;/pre&gt;</code> is safe, too.</p>
<pre><code>Good: &lt;li data-extra="{{data|json}}"&gt;…&lt;/li&gt;
Good: &lt;li data-extra='{{data|json|safe}}'&gt;…&lt;/li&gt;
Good: &lt;pre&gt;{{data|json|safe}}&lt;/pre&gt;
Good: &lt;script&gt;var data = {{data|json|safe}};&lt;/script&gt;

Bad:  &lt;li data-extra="{{data|json|safe}}"&gt;…&lt;/li&gt;
Bad:  &lt;script&gt;var data = {{data|json}};&lt;/script&gt;
Bad:  &lt;script&gt;var data = "{{data|json|safe}}";&lt;/script&gt;

Ugly: &lt;script&gt;var data = "{{data|json}}";&lt;/script&gt;
Ugly: &lt;script&gt;var data = '{{data|json|safe}}';&lt;/script&gt;
</code></pre>
<h2 id="custom-filters"><a class="header" href="#custom-filters">Custom Filters</a></h2>
<p>To define your own filters, simply have a module named <code>filters</code> in scope of the context deriving a <code>Template</code> impl
and define the filters as functions within this module.
The functions must have at least one argument and the return type must be <code>::askama::Result&lt;T&gt;</code>.
Although there are no restrictions on <code>T</code> for a single filter,
the final result of a chain of filters must implement <code>Display</code>.</p>
<p>The arguments to the filters are passed as follows.
The first argument corresponds to the expression they are applied to.
Subsequent arguments, if any, must be given directly when calling the filter.
The first argument may or may not be a reference, depending on the context in which the filter is called.
To abstract over ownership, consider defining your argument as a trait bound.
For example, the <code>trim</code> built-in filter accepts any value implementing <code>Display</code>.
Its signature is similar to <code>fn trim(s: impl std::fmt::Display) -&gt; ::askama::Result&lt;String&gt;</code>.</p>
<p>Note that built-in filters have preference over custom filters, so, in case of name collision, the built-in filter is applied.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Implementing a filter that replaces all instances of <code>"oo"</code> for <code>"aa"</code>.</p>
<pre><pre class="playground"><code class="language-rust">use askama::Template;

#[derive(Template)]
#[template(source = "{{ s|myfilter }}", ext = "txt")]
struct MyFilterTemplate&lt;'a&gt; {
    s: &amp;'a str,
}

// Any filter defined in the module `filters` is accessible in your template.
mod filters {
    // This filter does not have extra arguments
    pub fn myfilter&lt;T: std::fmt::Display&gt;(s: T) -&gt; ::askama::Result&lt;String&gt; {
        let s = s.to_string();
        Ok(s.replace("oo", "aa"))
    }
}

fn main() {
    let t = MyFilterTemplate { s: "foo" };
    assert_eq!(t.render().unwrap(), "faa");
}</code></pre></pre>
<p>Implementing a filter that replaces all instances of <code>"oo"</code> for <code>n</code> times <code>"a"</code>.</p>
<pre><pre class="playground"><code class="language-rust">use askama::Template;

#[derive(Template)]
#[template(source = "{{ s|myfilter(4) }}", ext = "txt")]
struct MyFilterTemplate&lt;'a&gt; {
    s: &amp;'a str,
}

// Any filter defined in the module `filters` is accessible in your template.
mod filters {
    // This filter requires a `usize` input when called in templates
    pub fn myfilter&lt;T: std::fmt::Display&gt;(s: T, n: usize) -&gt; ::askama::Result&lt;String&gt; {
        let s = s.to_string();
    	  let mut replace = String::with_capacity(n);
    	  replace.extend((0..n).map(|_| "a"));
        Ok(s.replace("oo", &amp;replace))
    }
}

fn main() {
    let t = MyFilterTemplate { s: "foo" };
    assert_eq!(t.render().unwrap(), "faaaa");
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrations"><a class="header" href="#integrations">Integrations</a></h1>
<h2 id="rocket-integration"><a class="header" href="#rocket-integration">Rocket integration</a></h2>
<p>In your template definitions, replace <code>askama::Template</code> with
<a href="https://docs.rs/askama_rocket"><code>askama_rocket::Template</code></a>.</p>
<p>Enabling the <code>with-rocket</code> feature appends an implementation of Rocket's
<code>Responder</code> trait for each template type. This makes it easy to trivially
return a value of that type in a Rocket handler. See
<a href="https://github.com/djc/askama/blob/main/askama_rocket/tests/basic.rs">the example</a>
from the Askama test suite for more on how to integrate.</p>
<p>In case a run-time error occurs during templating, a <code>500 Internal Server Error</code> <code>Status</code> value will be returned, so that this can be further
handled by your error catcher.</p>
<h2 id="actix-web-integration"><a class="header" href="#actix-web-integration">Actix-web integration</a></h2>
<p>In your template definitions, replace <code>askama::Template</code> with
<a href="https://docs.rs/askama_actix"><code>askama_actix::Template</code></a>.</p>
<p>Enabling the <code>with-actix-web</code> feature appends an implementation of Actix-web's
<code>Responder</code> trait for each template type. This makes it easy to trivially return
a value of that type in an Actix-web handler. See
<a href="https://github.com/djc/askama/blob/main/askama_actix/tests/basic.rs">the example</a>
from the Askama test suite for more on how to integrate.</p>
<h2 id="axum-integration"><a class="header" href="#axum-integration">Axum integration</a></h2>
<p>In your template definitions, replace <code>askama::Template</code> with
<a href="https://docs.rs/askama_axum"><code>askama_axum::Template</code></a>.</p>
<p>Enabling the <code>with-axum</code> feature appends an implementation of Axum's
<code>IntoResponse</code> trait for each template type. This makes it easy to trivially
return a value of that type in a Axum handler. See
<a href="https://github.com/djc/askama/blob/main/askama_axum/tests/basic.rs">the example</a>
from the Askama test suite for more on how to integrate.</p>
<p>In case of a run-time error occurring during templating, the response will be of the same
signature, with a status code of <code>500 Internal Server Error</code>, mime <code>*/*</code>, and an empty <code>Body</code>.
This preserves the response chain if any custom error handling needs to occur.</p>
<h2 id="warp-integration"><a class="header" href="#warp-integration">Warp integration</a></h2>
<p>In your template definitions, replace <code>askama::Template</code> with
<a href="https://docs.rs/askama_warp"><code>askama_warp::Template</code></a>.</p>
<p>Enabling the <code>with-warp</code> feature appends an implementation of Warp's <code>Reply</code>
trait for each template type. This makes it simple to return a template from
a Warp filter. See <a href="https://github.com/djc/askama/blob/main/askama_warp/tests/warp.rs">the example</a>
from the Askama test suite for more on how to integrate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<h2 id="slow-debug-recompilations"><a class="header" href="#slow-debug-recompilations">Slow Debug Recompilations</a></h2>
<p>If you experience slow compile times when iterating with lots of templates,
you can compile Askama's derive macros with a higher optimization level.
This can speed up recompilation times dramatically.</p>
<p>Add the following to <code>Cargo.toml</code> or <code>.cargo/config.toml</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[profile.dev.package.askama_derive]
opt-level = 3
<span class="boring">}</span></code></pre></pre>
<p>This may affect clean compile times in debug mode, but incremental compiles
will be faster.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-expansion"><a class="header" href="#template-expansion">Template Expansion</a></h1>
<p>This chapter will explain how the different parts of the templates are
translated into Rust code.</p>
<p>⚠️ Please note that the generated code might change in the future so the
following examples might not be up-to-date.</p>
<h2 id="basic-explanations"><a class="header" href="#basic-explanations">Basic explanations</a></h2>
<p>When you add <code>#[derive(Template)]</code> and <code>#[template(...)]</code> on your type, the
<code>Template</code> derive proc-macro will then generate an implementation of the
<code>askama::Template</code> trait which will be a Rust version of the template.</p>
<p>It will also implement the <code>std::fmt::Display</code> trait on your type which will
internally call the <code>askama::Template</code> trait.</p>
<p>Let's take a small example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Template)]
#[template(source = "{% set x = 12 %}", ext = "html")]
struct Mine;
<span class="boring">}</span></code></pre></pre>
<p>will generate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ::askama::Template for YourType {
    fn render_into(
        &amp;self,
        writer: &amp;mut (impl ::std::fmt::Write + ?Sized),
    ) -&gt; ::askama::Result&lt;()&gt; {
        let x = 12;
        ::askama::Result::Ok(())
    }
    const EXTENSION: ::std::option::Option&lt;&amp;'static ::std::primitive::str&gt; = Some(
        "html",
    );
    const SIZE_HINT: ::std::primitive::usize = 0;
    const MIME_TYPE: &amp;'static ::std::primitive::str = "text/html; charset=utf-8";
}

impl ::std::fmt::Display for YourType {
    #[inline]
    fn fmt(&amp;self, f: &amp;mut ::std::fmt::Formatter) -&gt; ::std::fmt::Result {
        ::askama::Template::render_into(self, f).map_err(|_| ::std::fmt::Error {})
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For simplicity, we will only keep the content of the <code>askama::Template::render_into</code>
function from now on.</p>
<h2 id="text-content"><a class="header" href="#text-content">Text content</a></h2>
<p>If you have "text content" (for example HTML) in your template:</p>
<pre><code class="language-html">&lt;h1&gt;{{ title }}&lt;/h1&gt;
</code></pre>
<p>It will generate it like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>writer
    .write_fmt(
        format_args!(
            "&lt;h1&gt;{0}&lt;/h1&gt;",
            &amp;::askama::MarkupDisplay::new_unsafe(&amp;(self.title), ::askama::Html),
        ),
    )?;
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>About <code>MarkupDisplay</code>: we need to use this type in order to prevent generating
invalid HTML. Let's take an example: if <code>title</code> is <code>"&lt;a&gt;"</code> and we display it as
is, in the generated HTML, you won't see <code>&lt;a&gt;</code> but instead a new HTML element
will be created. To prevent this, we need to escape some characters.</p>
<p>In this example, <code>&lt;a&gt;</code> will become <code>&amp;lt;a&amp;gt;</code>. And this is why there is the
<code>safe</code> builtin filter, in case you want it to be displayed as is.</p>
<h2 id="variables-1"><a class="header" href="#variables-1">Variables</a></h2>
<h3 id="variables-creation"><a class="header" href="#variables-creation">Variables creation</a></h3>
<p>If you create a variable in your template, it will be created in the generated
Rust code as well. For example:</p>
<pre><code class="language-jinja">{% set x = 12 %}
{% let y = x + 1 %}
</code></pre>
<p>will generate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 12;
let y = x + 1;
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<h3 id="variables-usage"><a class="header" href="#variables-usage">Variables usage</a></h3>
<p>By default, variables will reference a field from the type on which the <code>askama::Template</code>
trait is implemented:</p>
<pre><code class="language-jinja">{{ y }}
</code></pre>
<p>This template will expand as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>writer
    .write_fmt(
        format_args!(
            "{0}",
            &amp;::askama::MarkupDisplay::new_unsafe(&amp;(self.y), ::askama::Html),
        ),
    )?;
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>This is why if the variable is undefined, it won't work with Askama and why
we can't check if a variable is defined or not.</p>
<p>You can still access constants and statics by using paths. Let's say you have in
your Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: u32 = 0;
<span class="boring">}</span></code></pre></pre>
<p>Then you can use them in your template by referring to them with a path:</p>
<pre><code class="language-jinja">{{ crate::FOO }}{{ super::FOO }}{{ self::FOO }}
</code></pre>
<p>It will generate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>writer
    .write_fmt(
        format_args!(
            "{0}{1}{2}",
            &amp;::askama::MarkupDisplay::new_unsafe(&amp;(crate::FOO), ::askama::Html),
            &amp;::askama::MarkupDisplay::new_unsafe(&amp;(super::FOO), ::askama::Html),
            &amp;::askama::MarkupDisplay::new_unsafe(&amp;(self::FOO), ::askama::Html),
        ),
    )?;
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>(Note: <code>crate::</code> is to get an item at the root level of the crate, <code>super::</code> is
to get an item in the parent module and <code>self::</code> is to get an item in the
current module.)</p>
<p>You can also access items from the type that implements <code>Template</code> as well using
as <code>Self::</code>, it'll use the same logic.</p>
<h2 id="control-blocks"><a class="header" href="#control-blocks">Control blocks</a></h2>
<h3 id="ifelse"><a class="header" href="#ifelse">if/else</a></h3>
<p>The generated code can be more complex than expected, as seen with <code>if</code>/<code>else</code>
conditions:</p>
<pre><code class="language-jinja">{% if x == "a" %}
gateau
{% else %}
tarte
{% endif %}
</code></pre>
<p>It will generate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if *(&amp;(self.x == "a") as &amp;bool) {
    writer.write_str("gateau")?;
} else {
    writer.write_str("tarte")?;
}
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>Very much as expected except for the <code>&amp;(self.x == "a") as &amp;bool</code>. Now about why
the <code>as &amp;bool</code> is needed:</p>
<p>The following syntax <code>*(&amp;(...) as &amp;bool)</code> is used to  trigger Rust's automatic
dereferencing, to coerce e.g. <code>&amp;&amp;&amp;&amp;&amp;bool</code> to <code>bool</code>. First <code>&amp;(...) as &amp;bool</code>
coerces e.g. <code>&amp;&amp;&amp;bool</code> to <code>&amp;bool</code>. Then <code>*(&amp;bool)</code> finally dereferences it to
<code>bool</code>.</p>
<p>In short, it allows to fallback to a boolean as much as possible, but it also
explains why you can't do:</p>
<pre><code class="language-jinja">{% set x = "a" %}
{% if x %}
    {{ x }}
{% endif %}
</code></pre>
<p>Because it fail to compile because:</p>
<pre><code class="language-console">error[E0605]: non-primitive cast: `&amp;&amp;str` as `&amp;bool`
</code></pre>
<h3 id="if-let-1"><a class="header" href="#if-let-1">if let</a></h3>
<pre><code class="language-jinja">{% if let Some(x) = x %}
    {{ x }}
{% endif %}
</code></pre>
<p>will generate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(x) = &amp;(self.x) {
    writer
        .write_fmt(
            format_args!(
                "{0}",
                &amp;::askama::MarkupDisplay::new_unsafe(&amp;(x), ::askama::Html),
            ),
        )?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="loops"><a class="header" href="#loops">Loops</a></h3>
<pre><code class="language-html">{% for user in users %}
    {{ user }}
{% endfor %}
</code></pre>
<p>will generate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let _iter = (&amp;self.users).into_iter();
    for (user, _loop_item) in ::askama::helpers::TemplateLoop::new(_iter) {
        writer
            .write_fmt(
                format_args!(
                    "\n    {0}\n",
                    &amp;::askama::MarkupDisplay::new_unsafe(&amp;(user), ::askama::Html),
                ),
            )?;
    }
}
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>Now let's see what happens if you add an <code>else</code> condition:</p>
<pre><code class="language-jinja">{% for user in x if x.len() &gt; 2 %}
    {{ user }}
{% else %}
    {{ x }}
{% endfor %}
</code></pre>
<p>Which generates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let mut _did_loop = false;
    let _iter = (&amp;self.users).into_iter();
    for (user, _loop_item) in ::askama::helpers::TemplateLoop::new(_iter) {
        _did_loop = true;
        writer
            .write_fmt(
                format_args!(
                    "\n    {0}\n",
                    &amp;::askama::MarkupDisplay::new_unsafe(&amp;(user), ::askama::Html),
                ),
            )?;
    }
    if !_did_loop {
        writer
            .write_fmt(
                format_args!(
                    "\n    {0}\n",
                    &amp;::askama::MarkupDisplay::new_unsafe(
                        &amp;(self.x),
                        ::askama::Html,
                    ),
                ),
            )?;
    }
}
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>It creates a <code>_did_loop</code> variable which will check if we entered the loop. If
we didn't (because the iterator didn't return any value), it will enter the
<code>else</code> condition by checking <code>if !_did_loop {</code>.</p>
<p>We can extend it even further if we add an <code>if</code> condition on our loop:</p>
<pre><code class="language-jinja">{% for user in users if users.len() &gt; 2 %}
    {{ user }}
{% else %}
    {{ x }}
{% endfor %}
</code></pre>
<p>which generates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let mut _did_loop = false;
    let _iter = (&amp;self.users).into_iter();
    let _iter = _iter.filter(|user| -&gt; bool { self.users.len() &gt; 2 });
    for (user, _loop_item) in ::askama::helpers::TemplateLoop::new(_iter) {
        _did_loop = true;
        writer
            .write_fmt(
                format_args!(
                    "\n    {0}\n",
                    &amp;::askama::MarkupDisplay::new_unsafe(&amp;(user), ::askama::Html),
                ),
            )?;
    }
    if !_did_loop {
        writer
            .write_fmt(
                format_args!(
                    "\n    {0}\n",
                    &amp;::askama::MarkupDisplay::new_unsafe(
                        &amp;(self.x),
                        ::askama::Html,
                    ),
                ),
            )?;
    }
}
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>It generates an iterator but filters it based on the <code>if</code> condition (<code>users.len() &gt; 2</code>).
So once again, if the iterator doesn't return any value, we enter the <code>else</code>
condition.</p>
<p>Of course, if you only have a <code>if</code> and no <code>else</code>, the generated code is much
shorter:</p>
<pre><code class="language-jinja">{% for user in users if users.len() &gt; 2 %}
    {{ user }}
{% endfor %}
</code></pre>
<p>Which generates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let _iter = (&amp;self.users).into_iter();
    let _iter = _iter.filter(|user| -&gt; bool { self.users.len() &gt; 2 });
    for (user, _loop_item) in ::askama::helpers::TemplateLoop::new(_iter) {
        writer
            .write_fmt(
                format_args!(
                    "\n    {0}\n",
                    &amp;::askama::MarkupDisplay::new_unsafe(&amp;(user), ::askama::Html),
                ),
            )?;
    }
}
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<h2 id="filters-2"><a class="header" href="#filters-2">Filters</a></h2>
<p>Example of using the <code>abs</code> built-in filter:</p>
<pre><code class="language-jinja">{{ -2|abs }}
</code></pre>
<p>Which generates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>writer
    .write_fmt(
        format_args!(
            "{0}",
            &amp;::askama::MarkupDisplay::new_unsafe(
                &amp;(::askama::filters::abs(-2)?),
                ::askama::Html,
            ),
        ),
    )?;
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>The filter is called with <code>-2</code> as first argument. You can add further arguments
to the call like this:</p>
<pre><code class="language-jinja">{{ "a"|indent(4) }}
</code></pre>
<p>Which generates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>writer
    .write_fmt(
        format_args!(
            "{0}",
            &amp;::askama::MarkupDisplay::new_unsafe(
                &amp;(::askama::filters::indent("a", 4)?),
                ::askama::Html,
            ),
        ),
    )?;
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>No surprise there, <code>4</code> is added after <code>"a"</code>. Now let's check when we chain the filters:</p>
<pre><code class="language-jinja">{{ "a"|indent(4)|capitalize }}
</code></pre>
<p>Which generates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>writer
    .write_fmt(
        format_args!(
            "{0}",
            &amp;::askama::MarkupDisplay::new_unsafe(
                &amp;(::askama::filters::capitalize(
                    &amp;(::askama::filters::indent("a", 4)?),
                )?),
                ::askama::Html,
            ),
        ),
    )?;
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>As expected, <code>capitalize</code>'s first argument is the value returned by the <code>indent</code> call.</p>
<h2 id="macros-1"><a class="header" href="#macros-1">Macros</a></h2>
<p>This code:</p>
<pre><code class="language-html">{% macro heading(arg) %}
&lt;h1&gt;{{arg}}&lt;/h1&gt;
{% endmacro %}

{% call heading("title") %}
</code></pre>
<p>generates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let (arg) = (("title"));
    writer
        .write_fmt(
            format_args!(
                "\n&lt;h1&gt;{0}&lt;/h1&gt;\n",
                &amp;::askama::MarkupDisplay::new_unsafe(&amp;(arg), ::askama::Html),
            ),
        )?;
}
::askama::Result::Ok(())
<span class="boring">}</span></code></pre></pre>
<p>As you can see, the macro itself isn't present in the generated code, only its
internal code is generated as well as its arguments.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
